MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=3
PSVERSION_COMP=4
[preset00]
fRating=4.000
fGammaAdj=2.000
fDecay=0.980
fVideoEchoZoom=2.000
fVideoEchoAlpha=0.000
nVideoEchoOrientation=0
nWaveMode=0
bAdditiveWaves=0
bWaveDots=0
bWaveThick=0
bModWaveAlphaByVolume=0
bMaximizeWaveColor=1
bTexWrap=1
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=0
bDarken=0
bSolarize=0
bInvert=0
fWaveAlpha=0.800
fWaveScale=1.000
fWaveSmoothing=0.750
fWaveParam=0.000
fModWaveAlphaStart=0.750
fModWaveAlphaEnd=0.950
fWarpAnimSpeed=1.000
fWarpScale=1.000
fZoomExponent=1.00000
fShader=0.000
zoom=1.00000
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=1.00000
sx=1.00000
sy=1.00000
wave_r=0.000
wave_g=0.000
wave_b=0.000
wave_x=0.000
wave_y=0.000
ob_size=0.010
ob_r=0.000
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.010
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=12.000
nMotionVectorsY=9.000
mv_dx=0.000
mv_dy=0.000
mv_l=0.900
mv_r=1.000
mv_g=1.000
mv_b=1.000
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
per_frame_init_1=i=0; loop (5000,i[0]=0; gmem[i]=0; i+=1;);
per_frame_init_2=octaves=3; minbpm=75; maxbpm=190; nres_oct=70; 
per_frame_init_3=nres_extra=nres_oct/log(2)*log(maxbpm/minbpm/2);
per_frame_init_4=nres=nres_oct*octaves+nres_extra;
per_frame_init_5=bstep = log(2)/nres_oct;
per_frame_init_6=nres_out = ceil(nres_oct+nres_extra); //int is necessary !
per_frame_init_7=
per_frame_init_8=maxind = 40;
per_frame_init_9=i=0;
per_frame_init_10=loop (nres,
per_frame_init_11=  (8*i)[3]=minbpm*exp(i*bstep); 
per_frame_init_12=  if (i<=nres_out,(8*i)[4]=2*(1.5+i/nres_out)/2.5,0);; 
per_frame_init_13=i+=1); 
per_frame_init_14=
per_frame_init_15=camx=camy=camz=0; ax=ay=az=0; tilex=tiley=0;
per_frame_init_16=swct=0;
per_frame_init_17=oay=-1;
per_frame_init_18=pf=0.5;
per_frame_init_19=sp=1;
per_frame_1=dt = 1/fps; 
per_frame_2=tcorr = (dt - dt_);
per_frame_3=dt_= dt;
per_frame_4=treal += dt + tcorr*38;
per_frame_5=vol=2*bass+mid+treb;  
per_frame_6=d0= exp(-2.5*dt);
per_frame_7=i=0; avg = 0;
per_frame_8=loop (nres,
per_frame_9=  n = 8*i;
per_frame_10=  w = 2*$pi/60*n[3];
per_frame_11=  d = 1-dt*w*0.02; 
per_frame_12=  arg = treal*w + tcorr*15000; 
per_frame_13=  n[1] = n[1]*d +vol*cos(arg)*(1-d); //DFT real part
per_frame_14=  n[2] = n[2]*d +vol*sin(arg)*(1-d); //DFT imaginary part
per_frame_15=  if (i<nres_out, 
per_frame_16=    n2 = 8*(i+nres_oct);
per_frame_17=    n4 = 8*(i+nres_oct*2);
per_frame_18=    sum = sqrt (sqr(n[1])+sqr(n[2]) + sqr(n2[1])+sqr(n2[2]) + sqr(n4[1])+sqr(n4[2]));
per_frame_19=    avg += sum;
per_frame_20=//    n[0]= n[0]*d0+(1-d0)*n[4]*sum;
per_frame_21=
per_frame_22=    n[0]+= (n[4]*sum-n[0])*(1-d0);
per_frame_23=    if (n[0]>(8*promax)[0], promax=max(2,min(nres_out-2,i));,0); 
per_frame_24=  ,0);
per_frame_25=i += 1;);
per_frame_26=avg_ = avg_*d0 + (1-d0)*avg/nres_out;
per_frame_27=
per_frame_28=//Resist frequent BPM changes
per_frame_29=m8 = 8*maxind;
per_frame_30=wait += abs(m8[0]-(8*promax)[0])*dt*50; 
per_frame_31=if (wait>abs(promax-maxind)*80/nres_oct, maxind=promax; wait = 0,0);
per_frame_32=
per_frame_33=//OUTPUT
per_frame_34=BPM  = m8[3];
per_frame_35=BPMtime += BPM/60*dt*$pi; 
per_frame_36=d0=exp(-dt);
per_frame_37=quali= min(2.5,quali)*d0 + (1-d0)*m8[0];
per_frame_38=sBPM = d0*sBPM + (1-d0)*swing*BPM;
per_frame_39=BPM_ = BPM_*d0 + (1-d0)*BPM;
per_frame_40=swingtime += sBPM/60*dt*$pi/4;
per_frame_41=sElev = d0*sElev + (1-d0)*elev*0.1;
per_frame_42=elevTime += sElev*dt;
per_frame_43=
per_frame_44=//TRIGGERS
per_frame_45=camx=camy=camz=0;
per_frame_46=ax=0; ay=0; az=0;
per_frame_47=
per_frame_48=ay =  $pi+  2*atan (400*cos(BPMtime/18)); 
per_frame_49=az =  $pi/2+1*atan (400*cos(time*0.21)); 
per_frame_50=//az= 0;
per_frame_51=trigy = sin(ay)*oay<0;
per_frame_52=if (trigy, 
per_frame_53=  oay=sin(ay); 
per_frame_54=  swct +=1; 
per_frame_55=  t0=time/15;
per_frame_56=  mx=.6*cos(t0*3);
per_frame_57=  my=.6*cos(t0*5);
per_frame_58=  mz=0.1*cos(t0*7);
per_frame_59=  pf=1/pow(2,int(rand(4)));
per_frame_60=  sp = rand(2)>1;
per_frame_61=  r1 = rand(1);
per_frame_62=  tilex=rand(1)*0.2;
per_frame_63=  tiley=rand(1)*0.2;
per_frame_64=  rott=rand(1)-.5; 
per_frame_65=,0  );
per_frame_66=
per_frame_67=z=.5;
per_frame_68=xx = cos(time*0.4+z*0.6);
per_frame_69=yy = cos(time*0.4+z*0.3);
per_frame_70=
per_frame_71=test = sqrt(xx*xx+yy*yy);
per_frame_72=
per_frame_73=//cos(p.z*float2(.6,.3)+time*.4+dot(p,shapemod))
per_frame_74=
per_frame_75=q1=mx;
per_frame_76=q2=my ;
per_frame_77=q3=mz;
per_frame_78=
per_frame_79=q5=ax;
per_frame_80=q6=ay;
per_frame_81=q7=az;
per_frame_82=q8=max(0,quali/2-0.2)*8;
per_frame_83=q9=swct;
per_frame_84=q10=BPMTime;
per_frame_85=q11=pf;
per_frame_86=q12=sp;
per_frame_87=q13=r1;
per_frame_88=q14=tilex;
per_frame_89=q15=tiley;
per_frame_90=rot=rott;
per_frame_91=reg32 = aspecty;
per_frame_92=
per_frame_93=monitor = int(bpm) + quali*0.1;;
per_frame_94=monitor = test;
per_pixel_1=warp = 0;
per_pixel_2=zoom= 1/(1+int(q9)%5);
per_pixel_3=
per_pixel_4=dx=q14*sin(x*40);
per_pixel_5=dy=q15*sin(y*40);
warp_1=`#define sat saturate
warp_2=`#define tex sampler_Pattern_040
warp_3=`sampler tex;
warp_4=`static const float2 hor = float2 (2,0)*texsize.zw;
warp_5=`static const float2 ver = float2 (0,2)*texsize.zw;
warp_6=`static const int sel=int(q9)%3;
warp_7=`
warp_8=`
warp_9=`
warp_10=`shader_body
warp_11=`{
warp_12=`if (sel==0) {ret = (tex2D(tex,uv));}
warp_13=`else if (sel==1) {ret = (tex2D(tex,uv));}
warp_14=`else if (sel==2) {ret = (tex2D(tex,uv));}
warp_15=`}
warp_16=`
comp_1=`// Martin's milkdrop edit of XorDev's "Corridor" on shadertoy.com
comp_2=`
comp_3=`#define sat saturate
comp_4=`static const int maxiter = 36;
comp_5=`sampler sampler_pw_noise_lq;
comp_6=`float d,z,z0;
comp_7=`float3 rd,r,p,w, wall;
comp_8=`static const float3 scenerot = float3 (q5,q6,q7), shapemod = float3(q1, q2, q3);
comp_9=`static const float t=time;
comp_10=`
comp_11=`float3 RotXYZ (float3 p, float3 rot)
comp_12=`{ float3 c,s;
comp_13=`  sincos (rot,s,c);
comp_14=`  float3 q=p;
comp_15=`  q.yz= float2 (q.y*c.x - q.z*s.x, q.y*s.x + q.z*c.x);
comp_16=`  q.xz= float2 (q.x*c.y + q.z*s.y, -q.x*s.y + q.z*c.y);
comp_17=`  q.xy= float2 (q.x*c.z - q.y*s.z, q.x*s.z + q.y*c.z);
comp_18=`  return q;}
comp_19=`
comp_20=`
comp_21=`shader_body
comp_22=`{
comp_23=`  rd = normalize(float3((uv-.5)*aspect.xy, -.5) );
comp_24=`  rd=RotXYZ(rd, scenerot);
comp_25=`  w = abs(rd);
comp_26=`  w /= max(w.x, w.y);
comp_27=`  z0=w.z;
comp_28=`  w.z += t;
comp_29=`  w = 0.5 + (1 -abs(frac(w * 0.5)*2 - 1 )-0.5);
comp_30=`  
comp_31=`  float2 uv2 = frac(float2(w.x+w.y,w.z/2)/4);
comp_32=`//uv2 = float2(atan2(w.x,w.y)+.25,w.z/2)/4;
comp_33=`  wall = sin(12*(lum(GetPixel(uv2))))*0.4+0.5;
comp_34=`  if (q12) {wall*=.4;} else {wall*=0.15;}
comp_35=`
comp_36=`  ret = GetPixel(uv2)/z0*3;
comp_37=`  d = 0.0;
comp_38=`  z = .15;
comp_39=`  for (int i = 0.0; i < maxiter; i++)
comp_40=`  {
comp_41=`    r = -z * rd + float3 (1,1,t);
comp_42=`    p = float3(abs(fmod(abs(r.xy-2),4)-2),r.z);
comp_43=`    d = length(p.xy-1+.9*cos(p.z*float2(.6,.33)+time*.4+dot(p,shapemod))) + length(r-p) * wall*abs(cos(q12*p.z));
comp_44=`    z+=d*0.85;
comp_45=`   ret += (cos(p) + 1.4)*(0.6+q8*sat(z0/8)*pow(cos(q11*p.z+q10),16)) / d /(1+z);;
comp_46=`
comp_47=`     if (z>26) {i=maxiter;}  
comp_48=`    }
comp_49=`
comp_50=`
comp_51=`  ret = 1-exp(-ret / maxiter );
comp_52=`//ret = GetPixel(uv);
comp_53=`}
