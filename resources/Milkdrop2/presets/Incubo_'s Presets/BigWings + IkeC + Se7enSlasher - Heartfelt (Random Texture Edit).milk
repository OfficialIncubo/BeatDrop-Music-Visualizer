MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
[preset00]
fRating=3.000
fGammaAdj=2.000
fDecay=0.980
fVideoEchoZoom=2.000
fVideoEchoAlpha=0.000
nVideoEchoOrientation=0
nWaveMode=0
bAdditiveWaves=0
bWaveDots=0
bWaveThick=0
bModWaveAlphaByVolume=0
bMaximizeWaveColor=1
bTexWrap=1
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=0
bDarken=0
bSolarize=0
bInvert=0
fWaveAlpha=0.800
fWaveScale=1.000
fWaveSmoothing=0.750
fWaveParam=0.000
fModWaveAlphaStart=0.750
fModWaveAlphaEnd=0.950
fWarpAnimSpeed=1.000
fWarpScale=1.000
fZoomExponent=1.00000
fShader=0.000
zoom=1.00000
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=1.00000
sx=1.00000
sy=1.00000
wave_r=0.000
wave_g=0.000
wave_b=0.000
wave_x=0.000
wave_y=0.000
ob_size=0.010
ob_r=0.000
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.010
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=12.000
nMotionVectorsY=9.000
mv_dx=0.000
mv_dy=0.000
mv_l=0.900
mv_r=1.000
mv_g=1.000
mv_b=1.000
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
warp_1=`shader_body
warp_2=`{
warp_3=`    // sample previous frame
warp_4=`    ret = tex2D( sampler_main, uv ).xyz;
warp_5=`    
warp_6=`    // darken (decay) over time
warp_7=`    ret *= 0.98; //or try: ret -= 0.004;
warp_8=`}
comp_1=`// BigWings + IkeC - Heartfelt / https://www.shadertoy.com/view/ltffzl
comp_2=`// Transpiled to HLSL using Milkwave
comp_3=`
comp_4=`#define tx sin(time)*0.5+1 // 0.5 <= tx <= 1.5
comp_5=`
comp_6=`// CONV: setting iChannel samplers to default noise texture
comp_7=`#define iChannel0 sampler_rand00
comp_8=`//#define iChannel0 sampler_rand01
comp_9=`sampler iChannel0;
comp_10=`
comp_11=`// CONV: adding helper functions
comp_12=`float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_13=`float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_14=`float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_15=`float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_16=`
comp_17=`#define S(a, b, t) smoothstep(a, b, t)
comp_18=`#define HAS_HEART
comp_19=`#define USE_POST_PROCESSING
comp_20=`
comp_21=`#define stime 70
comp_22=`//#define stime 110
comp_23=`#define stimetotal 1.2*stime
comp_24=`
comp_25=`
comp_26=`float3 N13(float p) {
comp_27=` float3 p3 = frac(float3(p,p,p) * float3(.1031,.11369,.13787));
comp_28=` p3 += dot(p3, p3.yzx + 19.19);
comp_29=` return frac(float3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));
comp_30=`}
comp_31=`
comp_32=`float4 N14(float t) {
comp_33=` return frac(sin(t*float4(123., 1024., 1456., 264.))*float4(6547., 345., 8799., 1564.));
comp_34=`}
comp_35=`
comp_36=`float N(float t) {
comp_37=` return frac(sin(t*12345.564)*7658.76);
comp_38=`}
comp_39=`
comp_40=`float Saw(float b, float t) {
comp_41=` return S(0., b, t)*S(1., b, t);
comp_42=`}
comp_43=`
comp_44=`float2 DropLayer2(float2 uv_conv,  float t) {
comp_45=` float2 UV = uv_conv;
comp_46=`
comp_47=` uv_conv.y += t*0.75;
comp_48=` float2 a = float2(6., 1.);
comp_49=` float2 grid = a*2.;
comp_50=` float2 id = floor(uv_conv*grid);
comp_51=`
comp_52=` float colShift = N(id.x);
comp_53=` uv_conv.y += colShift;
comp_54=`
comp_55=` id = floor(uv_conv*grid);
comp_56=` float3 n = N13(id.x*35.2+id.y*2376.1);
comp_57=` float2 st = frac(uv_conv*grid)-float2(.5, 0);
comp_58=`
comp_59=` float x = n.x-.5;
comp_60=`
comp_61=` float y = UV.y*20.;
comp_62=` float wiggle = sin(y+sin(y));
comp_63=` x += wiggle*(.5-abs(x))*(n.z-.5);
comp_64=` x *= .7;
comp_65=` float ti = frac(t+n.z);
comp_66=` y = (Saw(.85, ti)-.5)*.9+.5;
comp_67=` float2 p = float2(x, y);
comp_68=`
comp_69=` float d = length((st-p)*a.yx);
comp_70=`
comp_71=` float mainDrop = S(.4, .0, d);
comp_72=`
comp_73=` float r = sqrt(S(1., y, st.y));
comp_74=` float cd = abs(st.x-x);
comp_75=` float trail = S(.23*r, .15*r*r, cd);
comp_76=` float trailFront = S(-.02, .02, st.y-y);
comp_77=` trail *= trailFront*r*r;
comp_78=`
comp_79=` y = UV.y;
comp_80=` float trail2 = S(.2*r, .0, cd);
comp_81=` float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;
comp_82=` y = frac(y*10.)+(st.y-.5);
comp_83=` float dd = length(st-float2(x, y));
comp_84=` droplets = S(.3, 0., dd);
comp_85=` float m = mainDrop+droplets*r*trailFront;
comp_86=`
comp_87=` return float2(m, trail);
comp_88=`}
comp_89=`
comp_90=`float StaticDrops(float2 uv_conv,  float t) {
comp_91=` uv_conv *= 40.;
comp_92=`
comp_93=` float2 id = floor(uv_conv);
comp_94=` uv_conv = frac(uv_conv)-.5;
comp_95=` float3 n = N13(id.x*107.45+id.y*3543.654);
comp_96=` float2 p = (n.xy-.5)*.7;
comp_97=` float d = length(uv_conv-p);
comp_98=`
comp_99=` float fade = Saw(.025, frac(t+n.z));
comp_100=` float c = S(.3, 0., d)*frac(n.z*10.)*fade;
comp_101=` return c;
comp_102=`}
comp_103=`
comp_104=`float2 Drops(float2 uv_conv,  float t, float l0, float l1, float l2) {
comp_105=` float s = StaticDrops(uv_conv, t)*l0;
comp_106=` float2 m1 = DropLayer2(uv_conv, t)*l1;
comp_107=` float2 m2 = DropLayer2(uv_conv*1.85, t)*l2;
comp_108=`
comp_109=` float c = s+m1.x+m2.x;
comp_110=` c = S(.3, 1., c);
comp_111=`
comp_112=` return float2(c, max(m1.y*l0, m2.y*l1));
comp_113=`}
comp_114=`
comp_115=`shader_body {
comp_116=` float4 fragColor = 0;
comp_117=` // CONV: Center on screen, then try some aspect correction
comp_118=` uv = (uv*2) - 1;
comp_119=` uv *= aspect.xy;
comp_120=` // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_121=` uv = float2(uv.x, -uv.y);
comp_122=`
comp_123=` float2 fragCoord  = uv;
comp_124=` //uv = (fragCoord.xy-.5*uv.xy) / uv.y;
comp_125=` 
comp_126=` float2 UV = fragCoord.xy/uv.xy;
comp_127=` // float2 UV = uv;
comp_128=`
comp_129=` // CONV: iMouse unsupported
comp_130=` // float3 M = iMouse.xyz/uv.xyz;
comp_131=` //float3 M = tx;
comp_132=` float f = 0.3;
comp_133=`
comp_134=` // drop flow speed?
comp_135=` float3 M = 5;
comp_136=` // float T = time+M.x*2.;
comp_137=` float T;  
comp_138=` 
comp_139=` #ifdef HAS_HEART
comp_140=`  //T = mod_conv(time, 102.);
comp_141=`  //T = lerp(T, M.x*102., M.z>0.?1.:0.);
comp_142=`  //T = lerp(T, M.x*102., 0);
comp_143=`  //T = fmod(time, stime);
comp_144=`  T=fmod(time, stimetotal);
comp_145=` #endif
comp_146=`
comp_147=` float t = T*.2;
comp_148=`
comp_149=` // CONV: iMouse unsupported
comp_150=` //float3 iMouse = float3(sin(time), sin(time), 1);
comp_151=` //float3 iMouse = tx;
comp_152=` float3 iMouse = 1;
comp_153=`
comp_154=` float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;
comp_155=`    
comp_156=` //float rainAmount = 1;
comp_157=`
comp_158=` float maxBlur = lerp(3., 6., rainAmount);
comp_159=` float minBlur = 2.;
comp_160=`     
comp_161=` float story = 0.;
comp_162=` float heart = 0.;
comp_163=`    
comp_164=` #ifdef HAS_HEART
comp_165=`  story = S(0., stime, T);
comp_166=`
comp_167=`  t = min(1., T/stime); // remap drop time so it goes slower when it freezes 
comp_168=`  t = 1.-t;
comp_169=`  t = (1.-t*t)*stime;
comp_170=`    
comp_171=`  // float zoom= lerp(.3, 1.2, story); // slowly zoom out
comp_172=`  float zoom= lerp(.4, 1.1, story); // slowly zoom out
comp_173=`  //uv = uv*zoom*0.2;
comp_174=`
comp_175=`  uv = uv*zoom*0.8;
comp_176=`
comp_177=`  minBlur = 4.+S(.5, 1., story)*3.; // more opaque glass towards the end  
comp_178=`  maxBlur = 6.+S(.5, 1., story)*1.5;
comp_179=`  
comp_180=`  float2 hv = uv-float2(.0, -.1); // build heart
comp_181=`  hv.x *= .5;
comp_182=`  float s = S(stimetotal, stime, T); // heart gets smaller and fades towards the end
comp_183=`  hv.y-=sqrt(abs(hv.x))*.5*s;
comp_184=`  heart = length(hv);
comp_185=`  heart = S(.4*s, .2*s, heart)*s;
comp_186=`  
comp_187=`  rainAmount = heart; // the rain is where the heart is  
comp_188=`  maxBlur-=heart; // inside the heart slighly less foggy
comp_189=`    
comp_190=`  float2 uvtx=uv*0.2;
comp_191=`  uv *= 1.5; // zoom out a bit more
comp_192=`  t *= .25;
comp_193=` #else
comp_194=`  float zoom = -cos(T*.2);
comp_195=`  uv *= .7+zoom*.3;
comp_196=` #endif
comp_197=`
comp_198=` UV = (UV-.5)*(.9+zoom*.1)+.5;
comp_199=`
comp_200=` float staticDrops = S(-.5, 1., rainAmount)*2.;
comp_201=` float layer1 = S(.25, .75, rainAmount); 
comp_202=` float layer2 = S(.0, .5, rainAmount);    
comp_203=`    
comp_204=` float2 c = Drops(uv, t, staticDrops, layer1, layer2);
comp_205=` 
comp_206=` #ifdef CHEAP_NORMALS
comp_207=`  float2 n = float2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))
comp_208=` #else
comp_209=`  float2 e = float2(.001, 0.);
comp_210=`  float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;
comp_211=`  float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;
comp_212=`  float2 n = float2(cx-c.x, cy-c.x); // expensive normals
comp_213=` #endif
comp_214=`    
comp_215=`    
comp_216=` #ifdef HAS_HEART
comp_217=`  // drop fading?
comp_218=`  n *= 1.-S(60., 85., T);
comp_219=`  c.y *= 1.-S(80., 100., T)*.8;
comp_220=` #endif
comp_221=`
comp_222=` float focus = lerp(maxBlur-c.y, minBlur, S(.1, .2, c.x));
comp_223=` // float3 col = textureLod(iChannel0, UV+n, focus).rgb;
comp_224=` // float3 col = iChannel0.SampleLevel(sampler0, UV + n, focus).rgb;
comp_225=` // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;
comp_226=` // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;
comp_227=`
comp_228=` // focus=1; n=0;
comp_229=` //float fac = 2.5;
comp_230=` float facx = 2.5;
comp_231=` float facy = 6;
comp_232=` float2 flippedUV = float2(uvtx.x*facx+0.5, 0.5-uvtx.y*facy);
comp_233=` //float2 flippedUV = float2(UV.x+0.5, 0.5-UV.y);
comp_234=`
comp_235=` float3 col = tex2Dlod(iChannel0, float4(flippedUV+n, 0, focus)).rgb;
comp_236=`
comp_237=` #ifdef USE_POST_PROCESSING  
comp_238=`  t = (T+3.)*.5; // make time sync with first lightning
comp_239=`  float colFade = sin(t*.2)*.5+.5+story;
comp_240=`  col *= lerp(float3(1., 1., 1.), float3(.8, .9, 1.3), colFade); // subtle color shift
comp_241=`
comp_242=`  float fade = S(0., 10., T*3); // fade in at the start
comp_243=`
comp_244=`
comp_245=`//float lightning = sin(t*sin(t*10)); // lighting flicker
comp_246=`
comp_247=`// Pseudo-random gate based on time
comp_248=`float chaos = frac(sin(floor(t * 0.5) * 12.9898) * 43758.5453); // changes every ~2s
comp_249=`float gate = step(0.1, chaos); // ~15% chance to allow flash
comp_250=`
comp_251=`// Smooth flash shape
comp_252=`float flashShape = pow(max(0.0, sin(t + sin(t * 0.5))), 12);
comp_253=`
comp_254=`// Lightning intensity
comp_255=`float lightning = sin(t*sin(t*10)) * 0.2; // lighting flicker
comp_256=`lightning *= flashShape * gate;
comp_257=`
comp_258=`// Composite
comp_259=`col *= 1.0 + lightning * fade * lerp(1.0, 0.1, story * story);
comp_260=`
comp_261=`/*  float lightning = sin(t * sin(t * 3.0)) * 0.3;
comp_262=`  lightning *= pow(max(0., sin(t+sin(t))), 10); // lightning flash
comp_263=`*/
comp_264=`
comp_265=`  //col *= 1.+lightning*fade*lerp(1., .1, story*story); // composite lightning  
comp_266=`
comp_267=`  #ifdef bass_smooth
comp_268=`   col = col+0.05*(clamp(bass_smooth, 0, 2)-1);
comp_269=`  #endif
comp_270=`  
comp_271=`  //col *= 1.-dot(UV-=.5, UV); // vignette
comp_272=`    											
comp_273=`  #ifdef HAS_HEART
comp_274=`   col = lerp(pow(col, float3(1.2, 1.2, 1.2)), col, heart);
comp_275=`   fade *= S(stimetotal, stimetotal-5, T);
comp_276=`  #endif
comp_277=`    
comp_278=`  col *= fade; // composite start and end fade
comp_279=` #endif
comp_280=`    
comp_281=` //col = float3(heart,heart,heart);
comp_282=` fragColor = float4(col, 1);
comp_283=` ret = fragColor;
comp_284=`}
