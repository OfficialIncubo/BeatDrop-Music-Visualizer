MILKDROP_PRESET_VERSION=201
PSVERSION=4
PSVERSION_WARP=4
PSVERSION_COMP=4
[preset00]
fRating=3.000
fGammaAdj=2.000
fDecay=0.980
fVideoEchoZoom=2.000
fVideoEchoAlpha=0.000
nVideoEchoOrientation=0
nWaveMode=0
bAdditiveWaves=0
bWaveDots=0
bWaveThick=0
bModWaveAlphaByVolume=0
bMaximizeWaveColor=1
bTexWrap=1
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=0
bDarken=0
bSolarize=0
bInvert=0
fWaveAlpha=0.800
fWaveScale=1.000
fWaveSmoothing=0.750
fWaveParam=0.000
fModWaveAlphaStart=0.750
fModWaveAlphaEnd=0.950
fWarpAnimSpeed=1.000
fWarpScale=1.000
fZoomExponent=1.00000
fShader=0.000
zoom=1.00000
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=1.00000
sx=1.00000
sy=1.00000
wave_r=0.000
wave_g=0.000
wave_b=0.000
wave_x=0.000
wave_y=0.000
ob_size=0.010
ob_r=0.000
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.010
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=12.000
nMotionVectorsY=9.000
mv_dx=0.000
mv_dy=0.000
mv_l=0.900
mv_r=1.000
mv_g=1.000
mv_b=1.000
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
warp_1=`shader_body
warp_2=`{
warp_3=`    // sample previous frame
warp_4=`    ret = tex2D( sampler_main, uv ).xyz;
warp_5=`    
warp_6=`    // darken (decay) over time
warp_7=`    ret *= 0.98; //or try: ret -= 0.004;
warp_8=`}
comp_1=`// BigWings + IkeC - Heartfelt / https://www.shadertoy.com/view/ltffzl
comp_2=`// Transpiled to HLSL using Milkwave
comp_3=`
comp_4=`#define tx sin(time)*0.5+1 // 0.5 <= tx <= 1.5
comp_5=`
comp_6=`// CONV: setting iChannel samplers to default noise texture
comp_7=`#define iChannel0 sampler_stoy_london
comp_8=`//#define iChannel0 sampler_grace
comp_9=`sampler iChannel0;
comp_10=`
comp_11=`// CONV: adding helper functions
comp_12=`float mod_conv(float x, float y) { return x - y * floor(x / y); }
comp_13=`float2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }
comp_14=`float3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }
comp_15=`float4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }
comp_16=`
comp_17=`#define S(a, b, t) smoothstep(a, b, t)
comp_18=`#define HAS_HEART
comp_19=`#define USE_POST_PROCESSING
comp_20=`
comp_21=`#define stime 70
comp_22=`//#define stime 110
comp_23=`#define stimetotal 1.2*stime
comp_24=`
comp_25=`
comp_26=`float3 N13(float p) {
comp_27=` float3 p3 = frac(float3(p,p,p) * float3(.1031,.11369,.13787));
comp_28=` p3 += dot(p3, p3.yzx + 19.19);
comp_29=` return frac(float3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));
comp_30=`}
comp_31=`
comp_32=`float4 N14(float t) {
comp_33=` return frac(sin(t*float4(123., 1024., 1456., 264.))*float4(6547., 345., 8799., 1564.));
comp_34=`}
comp_35=`
comp_36=`float N(float t) {
comp_37=` return frac(sin(t*12345.564)*7658.76);
comp_38=`}
comp_39=`
comp_40=`float Saw(float b, float t) {
comp_41=` return S(0., b, t)*S(1., b, t);
comp_42=`}
comp_43=`
comp_44=`float2 DropLayer2(float2 uv_conv,  float t) {
comp_45=` float2 UV = uv_conv;
comp_46=`
comp_47=` uv_conv.y += t*0.75;
comp_48=` float2 a = float2(6., 1.);
comp_49=` float2 grid = a*2.;
comp_50=` float2 id = floor(uv_conv*grid);
comp_51=`
comp_52=` float colShift = N(id.x);
comp_53=` uv_conv.y += colShift;
comp_54=`
comp_55=` id = floor(uv_conv*grid);
comp_56=` float3 n = N13(id.x*35.2+id.y*2376.1);
comp_57=` float2 st = frac(uv_conv*grid)-float2(.5, 0);
comp_58=`
comp_59=` float x = n.x-.5;
comp_60=`
comp_61=` float y = UV.y*20.;
comp_62=` float wiggle = sin(y+sin(y));
comp_63=` x += wiggle*(.5-abs(x))*(n.z-.5);
comp_64=` x *= .7;
comp_65=` float ti = frac(t+n.z);
comp_66=` y = (Saw(.85, ti)-.5)*.9+.5;
comp_67=` float2 p = float2(x, y);
comp_68=`
comp_69=` float d = length((st-p)*a.yx);
comp_70=`
comp_71=` float mainDrop = S(.4, .0, d);
comp_72=`
comp_73=` float r = sqrt(S(1., y, st.y));
comp_74=` float cd = abs(st.x-x);
comp_75=` float trail = S(.23*r, .15*r*r, cd);
comp_76=` float trailFront = S(-.02, .02, st.y-y);
comp_77=` trail *= trailFront*r*r;
comp_78=`
comp_79=` y = UV.y;
comp_80=` float trail2 = S(.2*r, .0, cd);
comp_81=` float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;
comp_82=` y = frac(y*10.)+(st.y-.5);
comp_83=` float dd = length(st-float2(x, y));
comp_84=` droplets = S(.3, 0., dd);
comp_85=` float m = mainDrop+droplets*r*trailFront;
comp_86=`
comp_87=` return float2(m, trail);
comp_88=`}
comp_89=`
comp_90=`float StaticDrops(float2 uv_conv,  float t) {
comp_91=` uv_conv *= 40.;
comp_92=`
comp_93=` float2 id = floor(uv_conv);
comp_94=` uv_conv = frac(uv_conv)-.5;
comp_95=` float3 n = N13(id.x*107.45+id.y*3543.654);
comp_96=` float2 p = (n.xy-.5)*.7;
comp_97=` float d = length(uv_conv-p);
comp_98=`
comp_99=` float fade = Saw(.025, frac(t+n.z));
comp_100=` float c = S(.3, 0., d)*frac(n.z*10.)*fade;
comp_101=` return c;
comp_102=`}
comp_103=`
comp_104=`float2 Drops(float2 uv_conv,  float t, float l0, float l1, float l2) {
comp_105=` float s = StaticDrops(uv_conv, t)*l0;
comp_106=` float2 m1 = DropLayer2(uv_conv, t)*l1;
comp_107=` float2 m2 = DropLayer2(uv_conv*1.85, t)*l2;
comp_108=`
comp_109=` float c = s+m1.x+m2.x;
comp_110=` c = S(.3, 1., c);
comp_111=`
comp_112=` return float2(c, max(m1.y*l0, m2.y*l1));
comp_113=`}
comp_114=`
comp_115=`shader_body {
comp_116=` float4 fragColor = 0;
comp_117=` // CONV: Center on screen, then try some aspect correction
comp_118=` uv = (uv*2) - 1;
comp_119=` uv *= aspect.xy;
comp_120=` // CONV: Adjust this to flip the output (±uv.x, ±uv.y)
comp_121=` uv = float2(uv.x, -uv.y);
comp_122=`
comp_123=` float2 fragCoord  = uv;
comp_124=` //uv = (fragCoord.xy-.5*uv.xy) / uv.y;
comp_125=` 
comp_126=` float2 UV = fragCoord.xy/uv.xy;
comp_127=` // float2 UV = uv;
comp_128=`
comp_129=` // CONV: iMouse unsupported
comp_130=` // float3 M = iMouse.xyz/uv.xyz;
comp_131=` //float3 M = tx;
comp_132=` float f = 0.3;
comp_133=`
comp_134=` // drop flow speed?
comp_135=` float3 M = 5;
comp_136=` // float T = time+M.x*2.;
comp_137=` float T;  
comp_138=` 
comp_139=` #ifdef HAS_HEART
comp_140=`  //T = mod_conv(time, 102.);
comp_141=`  //T = lerp(T, M.x*102., M.z>0.?1.:0.);
comp_142=`  //T = lerp(T, M.x*102., 0);
comp_143=`  //T = fmod(time, stime);
comp_144=`  T=fmod(time, stimetotal);
comp_145=` #endif
comp_146=`
comp_147=` float t = T*.2;
comp_148=`
comp_149=` // CONV: iMouse unsupported
comp_150=` //float3 iMouse = float3(sin(time), sin(time), 1);
comp_151=` //float3 iMouse = tx;
comp_152=` float3 iMouse = 1;
comp_153=`
comp_154=` float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;
comp_155=`    
comp_156=` //float rainAmount = 1;
comp_157=`
comp_158=` float maxBlur = lerp(3., 6., rainAmount);
comp_159=` float minBlur = 2.;
comp_160=`     
comp_161=` float story = 0.;
comp_162=` float heart = 0.;
comp_163=`    
comp_164=` #ifdef HAS_HEART
comp_165=`  story = S(0, 0, T*2);
comp_166=`
comp_167=`  t = time;
comp_168=`    
comp_169=`  // float zoom= lerp(.3, 1.2, story); // slowly zoom out
comp_170=`  float zoom= lerp(.4, 1.1, story); // slowly zoom out
comp_171=`  //uv = uv*zoom*0.2;
comp_172=`
comp_173=`  uv = uv*zoom*0.9;
comp_174=`
comp_175=`  minBlur = 4.+S(.5, 1., story)*3.; // more opaque glass towards the end  
comp_176=`  maxBlur = 6.+S(.5, 1., story)*1.5+bass_att/3;
comp_177=`  
comp_178=`  rainAmount = 1; // the rain is where the heart is  
comp_179=`  maxBlur-= 1; // inside the heart slighly less foggy
comp_180=`    
comp_181=`  float2 uvtx=uv*0.2;
comp_182=`  uv *= 1.5; // zoom out a bit more
comp_183=`  t *= .25;
comp_184=` #else
comp_185=`  float zoom = -cos(T*.2);
comp_186=`  uv *= .7+zoom*.3;
comp_187=` #endif
comp_188=`
comp_189=` UV = (UV-.5)*(.9+zoom*.1)+.5;
comp_190=`
comp_191=` float staticDrops = S(-.5, 1., rainAmount)*1.5;
comp_192=` float layer1 = S(.25, .75, rainAmount); 
comp_193=` float layer2 = S(.0, .5, rainAmount);    
comp_194=`    
comp_195=` float2 c = Drops(uv, t, staticDrops, layer1, layer2);
comp_196=` 
comp_197=` #ifdef CHEAP_NORMALS
comp_198=`  float2 n = float2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))
comp_199=` #else
comp_200=`  float2 e = float2(.001, 0.);
comp_201=`  float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;
comp_202=`  float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;
comp_203=`  float2 n = float2(cx-c.x, cy-c.x); // expensive normals
comp_204=` #endif
comp_205=`    
comp_206=` float focus = lerp(maxBlur-c.y, minBlur, S(.1, .2, c.x));
comp_207=` // float3 col = textureLod(iChannel0, UV+n, focus).rgb;
comp_208=` // float3 col = iChannel0.SampleLevel(sampler0, UV + n, focus).rgb;
comp_209=` // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;
comp_210=` // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;
comp_211=`
comp_212=` // focus=1; n=0;
comp_213=` //float fac = 2.5;
comp_214=` float facx = 2.5+bass_att;
comp_215=` float facy = 2;
comp_216=` float2 flippedUV = float2(uvtx.x*facx+0.5, 0.5-uvtx.y*facy);
comp_217=` //float2 flippedUV = float2(UV.x+0.5, 0.5-UV.y);
comp_218=`
comp_219=` float3 col = tex2Dlod(iChannel0, float4(flippedUV+n, 0, focus)).rgb;
comp_220=`    
comp_221=` //col = float3(heart,heart,heart);
comp_222=` fragColor = float4(col, 1);
comp_223=` ret = fragColor;
comp_224=`}
