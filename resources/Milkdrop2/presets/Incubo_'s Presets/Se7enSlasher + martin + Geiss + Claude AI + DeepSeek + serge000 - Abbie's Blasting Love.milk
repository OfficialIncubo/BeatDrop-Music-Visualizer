MILKDROP_PRESET_VERSION=201
PSVERSION=3
PSVERSION_WARP=3
PSVERSION_COMP=3
[preset00]
fRating=3.000
fGammaAdj=2.000
fDecay=0.925
fVideoEchoZoom=1.007
fVideoEchoAlpha=0.000
nVideoEchoOrientation=3
nWaveMode=7
bAdditiveWaves=1
bWaveDots=0
bWaveThick=0
bModWaveAlphaByVolume=1
bMaximizeWaveColor=0
bTexWrap=0
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=0
bDarken=0
bSolarize=0
bInvert=0
fWaveAlpha=0.000
fWaveScale=1.286
fWaveSmoothing=0.630
fWaveParam=0.000
fModWaveAlphaStart=0.710
fModWaveAlphaEnd=1.300
fWarpAnimSpeed=1.000
fWarpScale=1.331
fZoomExponent=1.00000
fShader=0.000
zoom=0.99951
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=0.01000
sx=1.00000
sy=1.00000
wave_r=0.650
wave_g=0.650
wave_b=0.650
wave_x=0.500
wave_y=0.500
ob_size=0.500
ob_r=0.010
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.260
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=12.000
nMotionVectorsY=9.000
mv_dx=0.000
mv_dy=0.000
mv_l=0.900
mv_r=1.000
mv_g=1.000
mv_b=1.000
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
wavecode_0_enabled=0
wavecode_0_samples=512
wavecode_0_sep=0
wavecode_0_bSpectrum=0
wavecode_0_bUseDots=0
wavecode_0_bDrawThick=0
wavecode_0_bAdditive=0
wavecode_0_scaling=1.00000
wavecode_0_smoothing=0.50000
wavecode_0_r=1.000
wavecode_0_g=1.000
wavecode_0_b=1.000
wavecode_0_a=1.000
wavecode_1_enabled=0
wavecode_1_samples=512
wavecode_1_sep=0
wavecode_1_bSpectrum=0
wavecode_1_bUseDots=0
wavecode_1_bDrawThick=0
wavecode_1_bAdditive=0
wavecode_1_scaling=1.00000
wavecode_1_smoothing=0.50000
wavecode_1_r=1.000
wavecode_1_g=1.000
wavecode_1_b=1.000
wavecode_1_a=1.000
wavecode_2_enabled=0
wavecode_2_samples=512
wavecode_2_sep=0
wavecode_2_bSpectrum=0
wavecode_2_bUseDots=0
wavecode_2_bDrawThick=0
wavecode_2_bAdditive=0
wavecode_2_scaling=1.00000
wavecode_2_smoothing=0.50000
wavecode_2_r=1.000
wavecode_2_g=1.000
wavecode_2_b=1.000
wavecode_2_a=1.000
wavecode_3_enabled=0
wavecode_3_samples=512
wavecode_3_sep=0
wavecode_3_bSpectrum=0
wavecode_3_bUseDots=0
wavecode_3_bDrawThick=0
wavecode_3_bAdditive=0
wavecode_3_scaling=1.00000
wavecode_3_smoothing=0.50000
wavecode_3_r=1.000
wavecode_3_g=1.000
wavecode_3_b=1.000
wavecode_3_a=1.000
shapecode_0_enabled=0
shapecode_0_sides=4
shapecode_0_additive=0
shapecode_0_thickOutline=0
shapecode_0_textured=0
shapecode_0_num_inst=1
shapecode_0_x=0.500
shapecode_0_y=0.500
shapecode_0_rad=0.10000
shapecode_0_ang=0.00000
shapecode_0_tex_ang=0.00000
shapecode_0_tex_zoom=1.00000
shapecode_0_r=1.000
shapecode_0_g=0.000
shapecode_0_b=0.000
shapecode_0_a=1.000
shapecode_0_r2=0.000
shapecode_0_g2=1.000
shapecode_0_b2=0.000
shapecode_0_a2=0.000
shapecode_0_border_r=1.000
shapecode_0_border_g=1.000
shapecode_0_border_b=1.000
shapecode_0_border_a=0.100
shapecode_1_enabled=0
shapecode_1_sides=4
shapecode_1_additive=0
shapecode_1_thickOutline=0
shapecode_1_textured=0
shapecode_1_num_inst=1
shapecode_1_x=0.500
shapecode_1_y=0.500
shapecode_1_rad=0.10000
shapecode_1_ang=0.00000
shapecode_1_tex_ang=0.00000
shapecode_1_tex_zoom=1.00000
shapecode_1_r=1.000
shapecode_1_g=0.000
shapecode_1_b=0.000
shapecode_1_a=1.000
shapecode_1_r2=0.000
shapecode_1_g2=1.000
shapecode_1_b2=0.000
shapecode_1_a2=0.000
shapecode_1_border_r=1.000
shapecode_1_border_g=1.000
shapecode_1_border_b=1.000
shapecode_1_border_a=0.100
shapecode_2_enabled=0
shapecode_2_sides=4
shapecode_2_additive=0
shapecode_2_thickOutline=0
shapecode_2_textured=0
shapecode_2_num_inst=1
shapecode_2_x=0.500
shapecode_2_y=0.500
shapecode_2_rad=0.10000
shapecode_2_ang=0.00000
shapecode_2_tex_ang=0.00000
shapecode_2_tex_zoom=1.00000
shapecode_2_r=1.000
shapecode_2_g=0.000
shapecode_2_b=0.000
shapecode_2_a=1.000
shapecode_2_r2=0.000
shapecode_2_g2=1.000
shapecode_2_b2=0.000
shapecode_2_a2=0.000
shapecode_2_border_r=1.000
shapecode_2_border_g=1.000
shapecode_2_border_b=1.000
shapecode_2_border_a=0.100
shapecode_3_enabled=0
shapecode_3_sides=4
shapecode_3_additive=0
shapecode_3_thickOutline=0
shapecode_3_textured=0
shapecode_3_num_inst=1
shapecode_3_x=0.500
shapecode_3_y=0.500
shapecode_3_rad=0.10000
shapecode_3_ang=0.00000
shapecode_3_tex_ang=0.00000
shapecode_3_tex_zoom=1.00000
shapecode_3_r=1.000
shapecode_3_g=0.000
shapecode_3_b=0.000
shapecode_3_a=1.000
shapecode_3_r2=0.000
shapecode_3_g2=1.000
shapecode_3_b2=0.000
shapecode_3_a2=0.000
shapecode_3_border_r=1.000
shapecode_3_border_g=1.000
shapecode_3_border_b=1.000
shapecode_3_border_a=0.100
per_frame_init_1=n = 0; loop (5000,megabuf(n) =0;gmegabuf(n) = 0; n+=1;);
per_frame_init_2=
per_frame_init_3=//don't touch this
per_frame_init_4=maxind = 0; 
per_frame_init_5=minbpm=75; maxbpm=600; n_res=100; 
per_frame_init_6=bpmstep = (maxbpm-minbpm)/n_res;
per_frame_init_7=
per_frame_init_8=//for display only
per_frame_init_9=reg99=n_res;
per_frame_init_10=
per_frame_init_11=ripple_form = 5 + int(rand(20))
per_frame_1=//Martin/Nitorami - DFT based beat detection with BPM identification
per_frame_2=//If you need a good BPM detection, why don't you simply use my code ? - Nitorami
per_frame_3=//Credits in comp shader code. Don't blame me.
per_frame_4=
per_frame_5=dt=1/fps;
per_frame_6=dec_m = exp(-2*dt); dec_s = exp(-.25*dt); 
per_frame_7=bvol = (2*bass+mid+treb); 
per_frame_8=bvol_=bvol_*dec_m + (1-dec_m)*bvol;
per_frame_9=exc=bvol-bvol_;
per_frame_10=i = 0;
per_frame_11=qavg = 0;
per_frame_12=loop (n_res,
per_frame_13=  n = i*8;
per_frame_14=  w = (minbpm+i*bpmstep)*2*$pi/60;
per_frame_15=//discrete Fourier transform
per_frame_16=  d=1-dt*w*0.016;
per_frame_17=  n[1] = n[1]*d+exc * cos (time*w)*(1-d); 
per_frame_18=  n[2] = n[2]*d+exc * sin (time*w)*(1-d); 
per_frame_19=  n[3] = n[3]*dec_m+(1-dec_m)*sqrt(sqr(n[2]) + sqr(n[1]));
per_frame_20=  if (n[3]> (maxind*8)[3], maxind = max(1,min(n_res-2,i)),0);
per_frame_21=  qavg += sqr(n[3]);
per_frame_22=  gmegabuf(i)= n[3];
per_frame_23=  i += 1;
per_frame_24=);
per_frame_25=avg = sqrt (qavg/n_res);
per_frame_26=
per_frame_27=//Interpolate exact BPM from DFT samples
per_frame_28=m=maxind;
per_frame_29=BL=minbpm+(m-1)*bpmstep;
per_frame_30=B0=minbpm+m*bpmstep;
per_frame_31=BH=minbpm+(m+1)*bpmstep;
per_frame_32=
per_frame_33=AL=sqr(((m-1)*8)[3]);
per_frame_34=A0=sqr((m*8)[3]);
per_frame_35=AH=sqr(((m+1)*8)[3]);
per_frame_36=
per_frame_37=BPM = (BL*AL + B0*A0 + BH*AH) / (AL+A0+AH);
per_frame_38=
per_frame_39=if (BPM>blim,  BPM*=.5; blim= 190;, blim=195);
per_frame_40=if (BPM>blim2, BPM*=.5; blim2=190;,blim2=195);
per_frame_41=
per_frame_42=//###############################################################
per_frame_43=//Code below is for visualisation only 
per_frame_44=
per_frame_45=trel1 += BPM/60*dt*$pi*2;
per_frame_46=q3 = cos(trel1/2);
per_frame_47=q2 = sin(trel1/2);
per_frame_48=q32=aspecty;
per_frame_49=
per_frame_50= //perceived detection quality
per_frame_51=quality = ((maxind*8)[3]/avg);
per_frame_52=q5 = min (1,quality*.15);
per_frame_53=
per_frame_54=//lowpass 2nd order for cursor movement
per_frame_55=fg = .4; Q=1; omega = 2*$pi*min(0.5,fg/fps); tcos = cos (omega); alpha = sin(omega)/(2*Q);
per_frame_56=b0=(1-tcos)/2; b1=1-tcos; b2=(1-tcos)/2; a0=1+alpha; a1=-2*tcos; a2=1-alpha;
per_frame_57=b0a0=b0/a0; b1a0=b1/a0; b2a0=b2/a0; a1a0=a1/a0; a2a0=a2/a0;
per_frame_58=
per_frame_59=Xa = BPM; LOa= b0a0*Xa + b1a0*in1a + b2a0*in2a - a1a0*ou1a - a2a0*ou2a;
per_frame_60=in2a =in1a; in1a =Xa; ou2a =ou1a;  ou1a =LOa; Xa =LOa;
per_frame_61=
per_frame_62=//Se7enSlasher - Convert BPM to integer and do a simple rounding.
per_frame_63=//intBPM = floor(BPM+.5); //More efficient way?
per_frame_64=intBPM = int(BPM);
per_frame_65=
per_frame_66=//Se7enSlasher - Timed Stop Technique
per_frame_67=
per_frame_68=//Se7enSlasher - Change the intBPM value to 0 when there is no sound.
per_frame_69=timeUntilStop = if (bass+mid+treb > 0, 2, timeUntilStop);
per_frame_70=timeUntilStop -= 1/fps;
per_frame_71=intBPM = if(timeUntilStop <= 0, 0, intBPM);
per_frame_72=
per_frame_73=linear_trans = if(!intBPM, linear_trans -= (1/fps)*3, linear_trans += (1/fps)*3);
per_frame_74=
per_frame_75=//Prevent from getting to gap (0 - 1).
per_frame_76=linear_trans = if(linear_trans < 0, 0, linear_trans);
per_frame_77=linear_trans = if(linear_trans > 1, 1, linear_trans);
per_frame_78=
per_frame_79=log_trans = log(linear_trans * 50 + 1) / 3.95;
per_frame_80=
per_frame_81=q7 = log_trans;
per_frame_82=
per_frame_83=//END
per_frame_84=
per_frame_85=q1 = intBPM;
per_frame_86=monitor = intBPM;
per_frame_87=
per_frame_88=time_imgsync += (1/fps) * (intBPM/30);
per_frame_89=time_imgsync = if (time_imgsync >= 4, 0, time_imgsync);
per_frame_90=q2 = pow(10, ((bass_att+mid_att+treb)/3.25)-3);
per_frame_91=q3 = int(time_imgsync);
per_frame_92=
per_frame_93=q4 = 1/aspectx;
per_frame_94=q5 = 1/aspecty+.75;
per_frame_95=
per_frame_96=BPMTime = (sin(time * $PI / (60 / intBPM)) + 1) / 2;
per_frame_97=q6 = BPMTime;
per_frame_98=time_delay = if(time_delay >= .35 && bass > 2, 0, time_delay += 1/fps);
per_frame_99=ripple_form = if(time_delay == 0, 5 + int(rand(20)), ripple_form);
per_frame_100=q8 = ripple_form;
per_frame_101=monitor = intBPM;
per_pixel_1=zoom = 1 + q2;
per_pixel_2=zoom += q2*sin(rad * q8 + time * 3.5);
warp_1=`sampler sampler_worms;
warp_2=`float3 color, mus;
warp_3=`float dx,dy;
warp_4=`shader_body {
warp_5=`
warp_6=`
warp_7=`float2 uv1 = (uv-.5) * aspect.xy;
warp_8=`
warp_9=`float2 uv6 = uv1;
warp_10=`float z = q10*24*length(((uv1.x)*(uv1.y)));
warp_11=`float2 d = normalize(uv1);
warp_12=`float2 rs = clamp(tan(z)*d,-2,2);
warp_13=`uv += .001*lum(GetBlur1(uv))*float2(0,0);
warp_14=`uv -= rs/200;
warp_15=`
warp_16=`uv6 = .4*sin(uv*5+rand_frame*8);
warp_17=`mus = .095/(length(uv6));  // sensit  orig:  .078
warp_18=`mus *= ((bass+mid)*1.75)*.34*float3(1, .575, .9);
warp_19=`
warp_20=`float3 blur = GetBlur2(frac(uv));
warp_21=`
warp_22=`float3 crisp= tex2D(sampler_main,uv);
warp_23=`
warp_24=`float3 ret1 = crisp - blur*.05 + .1*mus;
warp_25=`
warp_26=`q25 = 1;
warp_27=`ret = q25*(ret1*.99-.025) + (1-q25)* GetPixel(uv_orig);
warp_28=`
warp_29=`}
comp_1=`//Sprites are extracted using UndertaleModTool: https://github.com/UnderminersTeam/UndertaleModTool
comp_2=`//Credits: MINDWAVE by Holohammer. Play demo now: https://holohammer.com/mindwave/
comp_3=`
comp_4=`//Define textures with alternate name
comp_5=`#define AbbieDance1 sampler_fc_ibtS_spr_dance_0
comp_6=`#define AbbieDance2 sampler_fc_ibtS_spr_dance_1
comp_7=`#define AbbieDance3 sampler_fc_ibtS_spr_dance_2
comp_8=`#define AbbieDance4 sampler_fc_ibtS_spr_dance_3
comp_9=`
comp_10=`sampler AbbieDance1;
comp_11=`float4 texsize_ibtS_spr_dance_0;
comp_12=`sampler AbbieDance2;
comp_13=`float4 texsize_ibtS_spr_dance_1;
comp_14=`sampler AbbieDance3;
comp_15=`float4 texsize_ibtS_spr_dance_2;
comp_16=`sampler AbbieDance4;
comp_17=`float4 texsize_ibtS_spr_dance_3;
comp_18=`
comp_19=`float2 uv_scaled;
comp_20=`
comp_21=`// Deepseek - Universal edge fading function
comp_22=`// Modified EdgeFade function - fades top, left, and right edges only
comp_23=`float EdgeFade(float2 uva, float margin)
comp_24=`{
comp_25=`    margin = max(margin, 0.05); // Minimum margin to prevent artifacts - Tweaked a little bit.
comp_26=`    // Fade left/right edges
comp_27=`    float fadeX = smoothstep(0.0, margin, uva.x) * smoothstep(1.0, 1.0 - margin, uva.x);
comp_28=`    // Fade ONLY top edge (removed bottom edge fade)
comp_29=`    float fadeY = smoothstep(0.0, margin, uva.y);
comp_30=`    return fadeX * fadeY;
comp_31=`}
comp_32=`
comp_33=`shader_body
comp_34=`{
comp_35=`    ret = tex2D(sampler_main, uv).xyz;
comp_36=`    float2 reference_size = float2(1920, 1080)*14.275; // Fixed reference size (popular resolution is 1920x1080) and patched the aprox. 1080px image resolution by multiplying.
comp_37=`
comp_38=`    //Claude AI's Heart Code
comp_39=`    // Heart shape using standard mathematical formula
comp_40=`  float2 uv2 = uv - 0.5;
comp_41=`  uv2.x *= texsize.x/texsize.y;  // correct aspect ratio
comp_42=`  
comp_43=`  // Scale and flip the coordinates
comp_44=`  uv2.y = -uv2.y;
comp_45=`  uv2 *= 2.5;
comp_46=`  
comp_47=`  // Standard heart formula
comp_48=`  float2 q = float2(uv2.x, uv2.y - sqrt(abs(uv2.x))*0.5) + float2 (0, .125);
comp_49=`  float d = length(q) - 0.5 + 0.15*(-q6*2);
comp_50=`  
comp_51=`  // Create a soft glow effect
comp_52=`  float glow = 0.05/abs(d);
comp_53=`  glow = saturate(glow);
comp_54=`  
comp_55=`  // Add the heart with color
comp_56=`  float3 heartColor = float3(0.8, 0.1, 0.3);  // red heart
comp_57=`  heartColor *= 1.0 + .5*q6;  // pulsing effect
comp_58=`  
comp_59=`  // Combine everything
comp_60=`  float3 uv_heart = glow * heartColor*3; //Declare a new heart composition layer.
comp_61=`
comp_62=`  ret += uv_heart * q7;
comp_63=`
comp_64=`
comp_65=`    if (q3 == 0)
comp_66=`    {
comp_67=`       uv_scaled = float2(uv.x-.5,uv.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_0.zw + float2 (0.5, q7);
comp_68=`       uv_scaled += float2(.1925, 0); //Position fix
comp_69=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_70=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_71=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_72=`       //Se7enSlasher - Using my black background removal technique because it doesn't support transparency on any image files on MilkDrop. So I have implemented instead.
comp_73=`       float AbbieDance1_Lum = lum(tex2D(AbbieDance1, uv_scaled) * edgeFade);
comp_74=`
comp_75=`       if (AbbieDance1_Lum > .2)
comp_76=`       { ret = tex2D(AbbieDance1, uv_scaled);  }
comp_77=`    }
comp_78=`
comp_79=`    if (q3 == 1)
comp_80=`    {
comp_81=`       uv_scaled = float2(uv.x-.5,uv.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_1.zw + float2 (0.5, q7);
comp_82=`       uv_scaled += float2(.245, 0); //Position fix
comp_83=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_84=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_85=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_86=`
comp_87=`       float AbbieDance2_Lum = lum(tex2D(AbbieDance2, uv_scaled) * edgeFade);
comp_88=`
comp_89=`       if (AbbieDance2_Lum > .2)
comp_90=`       { ret = tex2D(AbbieDance2, uv_scaled);  }
comp_91=`    }
comp_92=`
comp_93=`    if (q3 == 2)
comp_94=`    {
comp_95=`       uv_scaled = float2(uv.x-.5,uv.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_2.zw + float2 (0.5, q7);
comp_96=`       uv_scaled += float2(-.19325, 0); //Position fix
comp_97=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_98=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_99=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_100=`
comp_101=`       float AbbieDance3_Lum = lum(tex2D(AbbieDance3, uv_scaled) * edgeFade);
comp_102=`
comp_103=`       if (AbbieDance3_Lum > .2)
comp_104=`       { ret = tex2D(AbbieDance3, uv_scaled);  }
comp_105=`    }
comp_106=`
comp_107=`    if (q3 == 3)
comp_108=`    {
comp_109=`       uv_scaled = float2(uv.x-.5,uv.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_3.zw + float2 (0.5, q7);
comp_110=`       uv_scaled += float2(-.26, 0); //Position fix
comp_111=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_112=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_113=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_114=`
comp_115=`       float AbbieDance4_Lum = lum(tex2D(AbbieDance4, uv_scaled) * edgeFade);
comp_116=`
comp_117=`       if (AbbieDance4_Lum > .2)
comp_118=`       { ret = tex2D(AbbieDance4, uv_scaled);  }
comp_119=`    }
comp_120=`
comp_121=`}
