MILKDROP_PRESET_VERSION=201
PSVERSION=3
PSVERSION_WARP=3
PSVERSION_COMP=3
[preset00]
fRating=3.000
fGammaAdj=2.000
fDecay=0.925
fVideoEchoZoom=1.007
fVideoEchoAlpha=0.000
nVideoEchoOrientation=3
nWaveMode=7
bAdditiveWaves=1
bWaveDots=0
bWaveThick=0
bModWaveAlphaByVolume=1
bMaximizeWaveColor=0
bTexWrap=0
bDarkenCenter=0
bRedBlueStereo=0
bBrighten=0
bDarken=0
bSolarize=0
bInvert=0
fWaveAlpha=0.000
fWaveScale=1.286
fWaveSmoothing=0.630
fWaveParam=0.000
fModWaveAlphaStart=0.710
fModWaveAlphaEnd=1.300
fWarpAnimSpeed=1.000
fWarpScale=1.331
fZoomExponent=1.00000
fShader=0.000
zoom=0.99951
rot=0.00000
cx=0.500
cy=0.500
dx=0.00000
dy=0.00000
warp=0.01000
sx=1.00000
sy=1.00000
wave_r=0.650
wave_g=0.650
wave_b=0.650
wave_x=0.500
wave_y=0.500
ob_size=0.500
ob_r=0.010
ob_g=0.000
ob_b=0.000
ob_a=0.000
ib_size=0.260
ib_r=0.250
ib_g=0.250
ib_b=0.250
ib_a=0.000
nMotionVectorsX=12.000
nMotionVectorsY=9.000
mv_dx=0.000
mv_dy=0.000
mv_l=0.900
mv_r=1.000
mv_g=1.000
mv_b=1.000
mv_a=0.000
b1n=0.000
b2n=0.000
b3n=0.000
b1x=1.000
b2x=1.000
b3x=1.000
b1ed=0.250
wavecode_0_enabled=0
wavecode_0_samples=512
wavecode_0_sep=0
wavecode_0_bSpectrum=0
wavecode_0_bUseDots=0
wavecode_0_bDrawThick=0
wavecode_0_bAdditive=0
wavecode_0_scaling=1.00000
wavecode_0_smoothing=0.50000
wavecode_0_r=1.000
wavecode_0_g=1.000
wavecode_0_b=1.000
wavecode_0_a=1.000
wavecode_1_enabled=0
wavecode_1_samples=512
wavecode_1_sep=0
wavecode_1_bSpectrum=0
wavecode_1_bUseDots=0
wavecode_1_bDrawThick=0
wavecode_1_bAdditive=0
wavecode_1_scaling=1.00000
wavecode_1_smoothing=0.50000
wavecode_1_r=1.000
wavecode_1_g=1.000
wavecode_1_b=1.000
wavecode_1_a=1.000
wavecode_2_enabled=0
wavecode_2_samples=512
wavecode_2_sep=0
wavecode_2_bSpectrum=0
wavecode_2_bUseDots=0
wavecode_2_bDrawThick=0
wavecode_2_bAdditive=0
wavecode_2_scaling=1.00000
wavecode_2_smoothing=0.50000
wavecode_2_r=1.000
wavecode_2_g=1.000
wavecode_2_b=1.000
wavecode_2_a=1.000
wavecode_3_enabled=0
wavecode_3_samples=512
wavecode_3_sep=0
wavecode_3_bSpectrum=0
wavecode_3_bUseDots=0
wavecode_3_bDrawThick=0
wavecode_3_bAdditive=0
wavecode_3_scaling=1.00000
wavecode_3_smoothing=0.50000
wavecode_3_r=1.000
wavecode_3_g=1.000
wavecode_3_b=1.000
wavecode_3_a=1.000
shapecode_0_enabled=0
shapecode_0_sides=4
shapecode_0_additive=0
shapecode_0_thickOutline=0
shapecode_0_textured=0
shapecode_0_num_inst=1
shapecode_0_x=0.500
shapecode_0_y=0.500
shapecode_0_rad=0.10000
shapecode_0_ang=0.00000
shapecode_0_tex_ang=0.00000
shapecode_0_tex_zoom=1.00000
shapecode_0_r=1.000
shapecode_0_g=0.000
shapecode_0_b=0.000
shapecode_0_a=1.000
shapecode_0_r2=0.000
shapecode_0_g2=1.000
shapecode_0_b2=0.000
shapecode_0_a2=0.000
shapecode_0_border_r=1.000
shapecode_0_border_g=1.000
shapecode_0_border_b=1.000
shapecode_0_border_a=0.100
shapecode_1_enabled=0
shapecode_1_sides=4
shapecode_1_additive=0
shapecode_1_thickOutline=0
shapecode_1_textured=0
shapecode_1_num_inst=1
shapecode_1_x=0.500
shapecode_1_y=0.500
shapecode_1_rad=0.10000
shapecode_1_ang=0.00000
shapecode_1_tex_ang=0.00000
shapecode_1_tex_zoom=1.00000
shapecode_1_r=1.000
shapecode_1_g=0.000
shapecode_1_b=0.000
shapecode_1_a=1.000
shapecode_1_r2=0.000
shapecode_1_g2=1.000
shapecode_1_b2=0.000
shapecode_1_a2=0.000
shapecode_1_border_r=1.000
shapecode_1_border_g=1.000
shapecode_1_border_b=1.000
shapecode_1_border_a=0.100
shapecode_2_enabled=0
shapecode_2_sides=4
shapecode_2_additive=0
shapecode_2_thickOutline=0
shapecode_2_textured=0
shapecode_2_num_inst=1
shapecode_2_x=0.500
shapecode_2_y=0.500
shapecode_2_rad=0.10000
shapecode_2_ang=0.00000
shapecode_2_tex_ang=0.00000
shapecode_2_tex_zoom=1.00000
shapecode_2_r=1.000
shapecode_2_g=0.000
shapecode_2_b=0.000
shapecode_2_a=1.000
shapecode_2_r2=0.000
shapecode_2_g2=1.000
shapecode_2_b2=0.000
shapecode_2_a2=0.000
shapecode_2_border_r=1.000
shapecode_2_border_g=1.000
shapecode_2_border_b=1.000
shapecode_2_border_a=0.100
shapecode_3_enabled=0
shapecode_3_sides=4
shapecode_3_additive=0
shapecode_3_thickOutline=0
shapecode_3_textured=0
shapecode_3_num_inst=1
shapecode_3_x=0.500
shapecode_3_y=0.500
shapecode_3_rad=0.10000
shapecode_3_ang=0.00000
shapecode_3_tex_ang=0.00000
shapecode_3_tex_zoom=1.00000
shapecode_3_r=1.000
shapecode_3_g=0.000
shapecode_3_b=0.000
shapecode_3_a=1.000
shapecode_3_r2=0.000
shapecode_3_g2=1.000
shapecode_3_b2=0.000
shapecode_3_a2=0.000
shapecode_3_border_r=1.000
shapecode_3_border_g=1.000
shapecode_3_border_b=1.000
shapecode_3_border_a=0.100
per_frame_init_1=n = 0; loop (5000,megabuf(n) =0;gmegabuf(n) = 0; n+=1;);
per_frame_init_2=
per_frame_init_3=//don't touch this
per_frame_init_4=maxind = 0; 
per_frame_init_5=minbpm=75; maxbpm=600; n_res=100; 
per_frame_init_6=bpmstep = (maxbpm-minbpm)/n_res;
per_frame_init_7=
per_frame_init_8=//for display only
per_frame_init_9=reg99=n_res;
per_frame_init_10=
per_frame_init_11=ripple_form = 5 + int(rand(20));
per_frame_init_12=rand_fin_kal = 4 + int(rand(4));
per_frame_1=//Martin/Nitorami - DFT based beat detection with BPM identification
per_frame_2=//If you need a good BPM detection, why don't you simply use my code ? - Nitorami
per_frame_3=//Credits in comp shader code. Don't blame me.
per_frame_4=
per_frame_5=dt=1/fps;
per_frame_6=dec_m = exp(-2*dt); dec_s = exp(-.25*dt); 
per_frame_7=bvol = (2*bass+mid+treb); 
per_frame_8=bvol_=bvol_*dec_m + (1-dec_m)*bvol;
per_frame_9=exc=bvol-bvol_;
per_frame_10=i = 0;
per_frame_11=qavg = 0;
per_frame_12=loop (n_res,
per_frame_13=  n = i*8;
per_frame_14=  w = (minbpm+i*bpmstep)*2*$pi/60;
per_frame_15=//discrete Fourier transform
per_frame_16=  d=1-dt*w*0.016;
per_frame_17=  n[1] = n[1]*d+exc * cos (time*w)*(1-d); 
per_frame_18=  n[2] = n[2]*d+exc * sin (time*w)*(1-d); 
per_frame_19=  n[3] = n[3]*dec_m+(1-dec_m)*sqrt(sqr(n[2]) + sqr(n[1]));
per_frame_20=  if (n[3]> (maxind*8)[3], maxind = max(1,min(n_res-2,i)),0);
per_frame_21=  qavg += sqr(n[3]);
per_frame_22=  gmegabuf(i)= n[3];
per_frame_23=  i += 1;
per_frame_24=);
per_frame_25=avg = sqrt (qavg/n_res);
per_frame_26=
per_frame_27=//Interpolate exact BPM from DFT samples
per_frame_28=m=maxind;
per_frame_29=BL=minbpm+(m-1)*bpmstep;
per_frame_30=B0=minbpm+m*bpmstep;
per_frame_31=BH=minbpm+(m+1)*bpmstep;
per_frame_32=
per_frame_33=AL=sqr(((m-1)*8)[3]);
per_frame_34=A0=sqr((m*8)[3]);
per_frame_35=AH=sqr(((m+1)*8)[3]);
per_frame_36=
per_frame_37=BPM = (BL*AL + B0*A0 + BH*AH) / (AL+A0+AH);
per_frame_38=
per_frame_39=if (BPM>blim,  BPM*=.5; blim= 190;, blim=195);
per_frame_40=if (BPM>blim2, BPM*=.5; blim2=190;,blim2=195);
per_frame_41=
per_frame_42=//###############################################################
per_frame_43=//Code below is for visualisation only 
per_frame_44=
per_frame_45=trel1 += BPM/60*dt*$pi*2;
per_frame_46=q3 = cos(trel1/2);
per_frame_47=q2 = sin(trel1/2);
per_frame_48=q32=aspecty;
per_frame_49=
per_frame_50= //perceived detection quality
per_frame_51=quality = ((maxind*8)[3]/avg);
per_frame_52=q5 = min (1,quality*.15);
per_frame_53=
per_frame_54=//lowpass 2nd order for cursor movement
per_frame_55=fg = .4; Q=1; omega = 2*$pi*min(0.5,fg/fps); tcos = cos (omega); alpha = sin(omega)/(2*Q);
per_frame_56=b0=(1-tcos)/2; b1=1-tcos; b2=(1-tcos)/2; a0=1+alpha; a1=-2*tcos; a2=1-alpha;
per_frame_57=b0a0=b0/a0; b1a0=b1/a0; b2a0=b2/a0; a1a0=a1/a0; a2a0=a2/a0;
per_frame_58=
per_frame_59=Xa = BPM; LOa= b0a0*Xa + b1a0*in1a + b2a0*in2a - a1a0*ou1a - a2a0*ou2a;
per_frame_60=in2a =in1a; in1a =Xa; ou2a =ou1a;  ou1a =LOa; Xa =LOa;
per_frame_61=
per_frame_62=//Se7enSlasher - Convert BPM to integer and do a simple rounding.
per_frame_63=//intBPM = floor(BPM+.5); //More efficient way?
per_frame_64=intBPM = int(BPM);
per_frame_65=
per_frame_66=//Se7enSlasher - Timed Stop Technique
per_frame_67=
per_frame_68=//Se7enSlasher - Change the intBPM value to 0 when there is no sound.
per_frame_69=timeUntilStop = if (bass+mid+treb > 0, 2, timeUntilStop);
per_frame_70=timeUntilStop -= 1/fps;
per_frame_71=intBPM = if(timeUntilStop <= 0, 0, intBPM);
per_frame_72=
per_frame_73=linear_trans = if(!intBPM, linear_trans -= (1/fps)*3, linear_trans += (1/fps)*3);
per_frame_74=
per_frame_75=//Prevent from getting to gap (0 - 1).
per_frame_76=linear_trans = if(linear_trans < 0, 0, linear_trans);
per_frame_77=linear_trans = if(linear_trans > 1, 1, linear_trans);
per_frame_78=
per_frame_79=log_trans = log(linear_trans * 50 + 1) / 3.95;
per_frame_80=
per_frame_81=q7 = log_trans;
per_frame_82=
per_frame_83=//END
per_frame_84=
per_frame_85=q1 = intBPM;
per_frame_86=monitor = intBPM;
per_frame_87=
per_frame_88=cool_krash_rotation_movement = abs(3.14*sin(time*0.345) + 3.14*sin(time*.234));
per_frame_89=q11=(2*abs((sin(time)-0.5))-cool_krash_rotation_movement); //Used for remix, I think it's not needed, anyways.
per_frame_90=
per_frame_91=time_imgsync += (1/fps) * (intBPM/30);
per_frame_92=time_imgsync = if (time_imgsync >= 4, 0, time_imgsync);
per_frame_93=q2 = pow(10, ((bass_att+mid_att+treb)/3)-3);
per_frame_94=q3 = int(time_imgsync);
per_frame_95=
per_frame_96=q4 = 1/aspectx;
per_frame_97=q5 = 1/aspecty+.75;
per_frame_98=
per_frame_99=BPMTime = (sin(time * $PI / (60 / intBPM)) + 1) / 2;
per_frame_100=q6 = BPMTime;
per_frame_101=time_delay = if(time_delay >= .35 && bass > 2, 0, time_delay += 1/fps);
per_frame_102=ripple_form = if(time_delay == 0, 5 + int(rand(20)), ripple_form);
per_frame_103=q8 = ripple_form;
per_frame_104=q9 = rand_fin_kal;
per_frame_105=
per_frame_106=monitor = intBPM;
per_pixel_1=zoom = 1 + q2;
per_pixel_2=zoom += q2*sin(rad * q8 + time * 3.5);
warp_1=`sampler sampler_worms;
warp_2=`float3 color, mus;
warp_3=`float dx,dy;
warp_4=`shader_body {
warp_5=`
warp_6=`
warp_7=`float2 uv1 = (uv-.5) * aspect.xy;
warp_8=`
warp_9=`float2 uv6 = uv1;
warp_10=`float z = q10*24*length(((uv1.x)*(uv1.y)));
warp_11=`float2 d = normalize(uv1);
warp_12=`float2 rs = clamp(tan(z)*d,-2,2);
warp_13=`uv += .001*lum(GetBlur1(uv))*float2(0,0);
warp_14=`uv -= rs/200;
warp_15=`
warp_16=`uv6 = .4*sin(uv*5+rand_frame*8);
warp_17=`mus = .095/(length(uv6));  // sensit  orig:  .078
warp_18=`mus *= ((bass+mid)*1.75)*.34*float3(1, .575, .9);
warp_19=`
warp_20=`float3 blur = GetBlur2(frac(uv));
warp_21=`
warp_22=`float3 crisp= tex2D(sampler_main,uv);
warp_23=`
warp_24=`float3 ret1 = crisp - blur*.05 + .1*mus;
warp_25=`
warp_26=`q25 = 1;
warp_27=`ret = q25*(ret1*.99-.025) + (1-q25)* GetPixel(uv_orig);
warp_28=`
warp_29=`}
comp_1=`//Sprites are extracted using UndertaleModTool: https://github.com/UnderminersTeam/UndertaleModTool
comp_2=`//Credits: MINDWAVE by Holohammer. Play demo now: https://holohammer.com/mindwave/
comp_3=`
comp_4=`//Define textures with alternate name
comp_5=`#define AbbieDance1 sampler_fc_ibtS_spr_dance_0
comp_6=`#define AbbieDance2 sampler_fc_ibtS_spr_dance_1
comp_7=`#define AbbieDance3 sampler_fc_ibtS_spr_dance_2
comp_8=`#define AbbieDance4 sampler_fc_ibtS_spr_dance_3
comp_9=`
comp_10=`sampler AbbieDance1;
comp_11=`float4 texsize_ibtS_spr_dance_0;
comp_12=`sampler AbbieDance2;
comp_13=`float4 texsize_ibtS_spr_dance_1;
comp_14=`sampler AbbieDance3;
comp_15=`float4 texsize_ibtS_spr_dance_2;
comp_16=`sampler AbbieDance4;
comp_17=`float4 texsize_ibtS_spr_dance_3;
comp_18=`
comp_19=`float2 uv_scaled;
comp_20=`float2 uv_out;
comp_21=`
comp_22=`// Deepseek - Universal edge fading function
comp_23=`// Modified EdgeFade function - fades top, left, and right edges only
comp_24=`float EdgeFade(float2 uva, float margin)
comp_25=`{
comp_26=`    margin = max(margin, 0.05); // Minimum margin to prevent artifacts - Tweaked a little bit.
comp_27=`    // Fade left/right edges
comp_28=`    float fadeX = smoothstep(0.0, margin, uva.x) * smoothstep(1.0, 1.0 - margin, uva.x);
comp_29=`    // Fade ONLY top edge (removed bottom edge fade)
comp_30=`    float fadeY = smoothstep(0.0, margin, uva.y);
comp_31=`    return fadeX * fadeY;
comp_32=`}
comp_33=`
comp_34=`shader_body
comp_35=`{
comp_36=`//DeepSeek
comp_37=`float zoomFactor = 1.0 + bass_att * 0.035; // Adjust the multiplier to control the zoom intensity, tweaked by me
comp_38=`uv = float2(0.5, 0.5) + (uv_orig - float2(0.5, 0.5)) / zoomFactor;
comp_39=`
comp_40=`//ROVASTAR's Kaleidoscope Code, mashed up with Krash's movement code.
comp_41=`
comp_42=`    float rad_lq = rad * length(texsize.xy)*0.5;
comp_43=`    float ang_lq = ang;
comp_44=`    float2 uv_temp1 = (uv - 0.5) * texsize.xy;
comp_45=`    float rad_hq = length(uv_temp1);
comp_46=`    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);
comp_47=`
comp_48=`    float2 uv_kal = (uv - 0.5);
comp_49=`    float rad2 = rad_hq*0.8;
comp_50=`    float ang2 = ang_hq * M_INV_PI_2;
comp_51=`
comp_52=`        // ROTATION OVER TIME
comp_53=`        #if 1
comp_54=`          ang2 -= q11/7.5;   //rotate over time
comp_55=`        #endif
comp_56=`
comp_57=`        // FIN TYPE
comp_58=`        //float fins = 1 + floor(rand_preset.z*5.95);
comp_59=`        float fins = q9 + floor(rand_preset.z*2.95);
comp_60=`              
comp_61=`        #if 1     // SHARP FINS
comp_62=`          ang2 = frac(ang2*fins)/fins;
comp_63=`              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)
comp_64=`              ang2 = abs(ang2 - 0.5/fins);
comp_65=`        #else     // COSINE FINS - a bit slow
comp_66=`          ang2 = cos(ang2*M_PI_2*fins) * 0.023;
comp_67=`        #endif
comp_68=`
comp_69=`        // RADIAL KALEIDOSCOPING?
comp_70=`        #if 0
comp_71=`          rad2 *= g_fTexSize.z;
comp_72=`            // choose one:
comp_73=`            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.6);
comp_74=`            rad2 = cos(rad2*5);
comp_75=`            //rad2 = sqrt(rad2)*0.5;
comp_76=`            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier
comp_77=`            //rad2 += cos(rad2*61)*0.02;
comp_78=`          rad2 *= g_fTexSize.x;
comp_79=`        #endif
comp_80=`
comp_81=`    ang2 *= M_PI_2;
comp_82=`    uv_out = 0.25 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;
comp_83=`    uv_out.y = 1.1-uv_out.y;
comp_84=`
comp_85=`    ret = tex2D(sampler_main, uv_out).xyz;
comp_86=`
comp_87=`    float2 reference_size = float2(1920, 1080)*14.275; // Fixed reference size (popular resolution is 1920x1080) and patched the aprox. 1080px image resolution by multiplying.
comp_88=`
comp_89=`    if (q3 == 0)
comp_90=`    {
comp_91=`       uv_scaled = float2(uv_out.x-.5,uv_out.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_0.zw + float2 (0.5, q7);
comp_92=`       uv_scaled += float2(.1925, 0); //Position fix
comp_93=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_94=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_95=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_96=`
comp_97=`       //Se7enSlasher - Using my black background removal technique because it doesn't support transparency on any image files on MilkDrop. So I have implemented instead.
comp_98=`       float AbbieDance1_Lum = lum(tex2D(AbbieDance1, uv_scaled) * edgeFade);
comp_99=`
comp_100=`       if (AbbieDance1_Lum > .2)
comp_101=`       { ret = tex2D(AbbieDance1, uv_scaled);  }
comp_102=`    }
comp_103=`
comp_104=`    if (q3 == 1)
comp_105=`    {
comp_106=`       uv_scaled = float2(uv_out.x-.5,uv_out.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_1.zw + float2 (0.5, q7);
comp_107=`       uv_scaled += float2(.245, 0); //Position fix
comp_108=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_109=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_110=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_111=`
comp_112=`       float AbbieDance2_Lum = lum(tex2D(AbbieDance2, uv_scaled) * edgeFade);
comp_113=`
comp_114=`       if (AbbieDance2_Lum > .2)
comp_115=`       { ret = tex2D(AbbieDance2, uv_scaled);  }
comp_116=`    }
comp_117=`
comp_118=`    if (q3 == 2)
comp_119=`    {
comp_120=`       uv_scaled = float2(uv_out.x-.5,uv_out.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_2.zw + float2 (0.5, q7);
comp_121=`       uv_scaled += float2(-.19325, 0); //Position fix
comp_122=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_123=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_124=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_125=`
comp_126=`       float AbbieDance3_Lum = lum(tex2D(AbbieDance3, uv_scaled) * edgeFade);
comp_127=`
comp_128=`       if (AbbieDance3_Lum > .2)
comp_129=`       { ret = tex2D(AbbieDance3, uv_scaled);  }
comp_130=`    }
comp_131=`
comp_132=`    if (q3 == 3)
comp_133=`    {
comp_134=`       uv_scaled = float2(uv_out.x-.5,uv_out.y-1)/5.35 * reference_size * texsize_ibtS_spr_dance_3.zw + float2 (0.5, q7);
comp_135=`       uv_scaled += float2(-.26, 0); //Position fix
comp_136=`       uv_scaled *= (uv_scaled.x>0) * (uv_scaled.y>0) * (uv_scaled.x<1) * (uv_scaled.y<1);
comp_137=`       uv_scaled = clamp(uv_scaled, 0.0, 1.0); // Proper UV clamping
comp_138=`       float edgeFade = EdgeFade(uv_scaled, 0.01); // 1% margin fading
comp_139=`
comp_140=`       float AbbieDance4_Lum = lum(tex2D(AbbieDance4, uv_scaled) * edgeFade);
comp_141=`
comp_142=`       if (AbbieDance4_Lum > .2)
comp_143=`       { ret = tex2D(AbbieDance4, uv_scaled);  }
comp_144=`    }
comp_145=`
comp_146=`      //Claude AI's Heart Code
comp_147=`    // Heart shape using standard mathematical formula
comp_148=`  float2 uv2 = uv - 0.5;
comp_149=`  uv2.x *= texsize.x/texsize.y;  // correct aspect ratio
comp_150=`  
comp_151=`  // Scale and flip the coordinates
comp_152=`  uv2.y = -uv2.y;
comp_153=`  uv2 *= 2.5;
comp_154=`  
comp_155=`  // Standard heart formula
comp_156=`  float2 q = float2(uv2.x, uv2.y - sqrt(abs(uv2.x))*0.5) + float2 (0, .125);
comp_157=`  float d = length(q) - 0.5 + 0.15*(-q6*2);
comp_158=`  
comp_159=`  // Create a soft glow effect
comp_160=`  float glow = 0.05/abs(d);
comp_161=`  glow = saturate(glow);
comp_162=`  
comp_163=`  // Add the heart with color
comp_164=`  float3 heartColor = float3(0.8, 0.1, 0.3);  // red heart
comp_165=`  heartColor *= 1.0 + .5*q6;  // pulsing effect
comp_166=`  
comp_167=`  // Combine everything
comp_168=`  float3 uv_heart = glow * heartColor*3; //Declare a new heart composition layer.
comp_169=`  //ret = uv_out;
comp_170=`  ret += uv_heart * q7;
comp_171=`
comp_172=`}
